package rag

import (
	"context"

	"github.com/openai/openai-go/v3"
	"github.com/snipwise/nova/nova-sdk/agents"
	"github.com/snipwise/nova/nova-sdk/models"
	"github.com/snipwise/nova/nova-sdk/toolbox/conversion"
	"github.com/snipwise/nova/nova-sdk/toolbox/logger"

	"github.com/snipwise/nova/nova-sdk/agents/rag/stores"
)

type BaseAgent struct {
	ctx             context.Context
	config          agents.Config
	EmbeddingParams openai.EmbeddingNewParams
	openaiClient    openai.Client
	log             logger.Logger

	store stores.VectorStore

	// Internal fields for automatic persistence
	jsonStorePathFile    string // Path to JSON store file (set by WithJsonStore)
	documentsAddedCount  int    // Number of documents added by WithDocuments

	lastRequestJSON  string
	lastResponseJSON string
}

// DocumentLoadMode defines how documents should be loaded when a store already contains data
type DocumentLoadMode string

const (
	// DocumentLoadModeOverwrite replaces all existing data with new documents
	DocumentLoadModeOverwrite DocumentLoadMode = "overwrite"
	// DocumentLoadModeMerge adds new documents to existing data (default)
	DocumentLoadModeMerge DocumentLoadMode = "merge"
	// DocumentLoadModeSkip does nothing if store already contains data
	DocumentLoadModeSkip DocumentLoadMode = "skip"
	// DocumentLoadModeSkipDuplicates checks each document individually and skips only duplicates based on Prompt content
	DocumentLoadModeSkipDuplicates DocumentLoadMode = "skip_duplicates"
	// DocumentLoadModeError returns an error if store is not empty
	DocumentLoadModeError DocumentLoadMode = "error"
)

type AgentOption func(*BaseAgent)

// NewBaseAgent creates a new RAG agent with OpenAI SDK integration
func NewBaseAgent(
	ctx context.Context,
	agentConfig agents.Config,
	modelConfig openai.EmbeddingNewParams,
	options ...AgentOption,
) (ragAgent *BaseAgent, err error) {

	client, log, err := agents.InitializeConnection(ctx, agentConfig, models.Config{
		Name: modelConfig.Model,
	})

	if err != nil {
		return nil, err
	}

	ragAgent = &BaseAgent{
		ctx:             ctx,
		config:          agentConfig,
		EmbeddingParams: modelConfig,
		openaiClient:    client,
		log:             log,

		store: &stores.MemoryVectorStore{
			Records: make(map[string]stores.VectorRecord),
		},
	}

	// Apply options (which may override the default store)
	for _, opt := range options {
		opt(ragAgent)
	}

	// Automatic persistence: if using JsonStore and documents were added, persist automatically
	if ragAgent.jsonStorePathFile != "" && ragAgent.documentsAddedCount > 0 {
		if err := ragAgent.PersistStore(ragAgent.jsonStorePathFile); err != nil {
			ragAgent.log.Error("Failed to automatically persist store to %s: %v", ragAgent.jsonStorePathFile, err)
		} else {
			ragAgent.log.Debug("Automatically persisted %d documents to %s", ragAgent.documentsAddedCount, ragAgent.jsonStorePathFile)
		}
	}

	return ragAgent, nil
}

// GenerateEmbeddingVector creates a vector embedding for the given text content using the agent's embedding model
func (agent *BaseAgent) GenerateEmbeddingVector(content string) (embeddingVector []float64, err error) {
	// Create embedding parameters using the agent's embedding parameters

	agent.EmbeddingParams.Input = openai.EmbeddingNewParamsInputUnion{
		OfString: openai.String(content),
	}

	agent.SaveLastEmbeddingRequest()

	// Use the client to create embeddings
	embeddingResponse, err := agent.openaiClient.Embeddings.New(agent.ctx, agent.EmbeddingParams)
	if err != nil {
		return nil, err
	}

	agent.SaveLastEmbeddingResponse(embeddingResponse)

	return embeddingResponse.Data[0].Embedding, nil
}

// Embedding vector dimension: the size of the produced vector (e.g., 384, 768, 1024, 3072 dimensions).
// GetEmbeddingDimension returns the dimension of the embedding vectors generated by the agent's model
func (agent *BaseAgent) GetEmbeddingDimension() int {
	vector, err := agent.GenerateEmbeddingVector("hello")
	if err != nil {
		return 0
	}
	return len(vector)
}

// GenerateThenSaveEmbeddingVector creates a vector embedding for the given text content
func (agent *BaseAgent) GenerateThenSaveEmbeddingVector(content string) (err error) {
	embeddingVector, err := agent.GenerateEmbeddingVector(content)
	if err != nil {
		return err
	}

	_, errSave := agent.store.Save(stores.VectorRecord{
		Prompt:    content,
		Embedding: embeddingVector,
	})

	if errSave != nil {
		return errSave
	}

	return nil
}

// SearchSimilarities searches the vector store for similar records based on the embedding of the provided content
// and returns the top results up to the specified limit
// Parameters:
//   - content: the text content to generate an embedding for searching.
//   - limit: the minimum cosine distance similarity threshold. 1.0 means exact match, 0.0 means no similarity.
func (agent *BaseAgent) SearchSimilarities(content string, limit float64) (results []stores.VectorRecord, err error) {
	embeddingVector, err := agent.GenerateEmbeddingVector(content)
	if err != nil {
		return nil, err
	}

	vectorRecord := stores.VectorRecord{
		Prompt:    content,
		Embedding: embeddingVector,
	}

	results, err = agent.store.SearchSimilarities(vectorRecord, limit)
	if err != nil {
		return nil, err
	}

	return results, nil
}

// SearchTopNSimilarities searches the vector store for similar records based on the embedding of the provided content
// and returns the top N results above the specified similarity limit
// Parameters:
//   - content: the text content to generate an embedding for searching.
//   - limit: the minimum cosine distance similarity threshold. 1.0 means exact match, 0.0 means no similarity.
//   - n: the maximum number of top similar records to return.
func (agent *BaseAgent) SearchTopNSimilarities(content string, limit float64, n int) (results []stores.VectorRecord, err error) {
	embeddingVector, err := agent.GenerateEmbeddingVector(content)
	if err != nil {
		return nil, err
	}

	vectorRecord := stores.VectorRecord{
		Prompt:    content,
		Embedding: embeddingVector,
	}

	results, err = agent.store.SearchTopNSimilarities(vectorRecord, limit, n)
	if err != nil {
		return nil, err
	}

	return results, nil
}

// === Store Management ===

// PersistStore saves the in-memory vector store to a file (JSON format)
// This method is automatically called by NewBaseAgent when using WithJsonStore + WithDocuments
// Parameters:
//   - storeFilePath: path to the file where the store will be saved
//
// Returns an error if:
//   - The store doesn't support file-based persistence (e.g., Redis stores)
//   - There's an error during file writing
func (agent *BaseAgent) PersistStore(storeFilePath string) error {
	// Check if the store supports persistence
	if persistable, ok := agent.store.(interface {
		Persist(string) error
	}); ok {
		return persistable.Persist(storeFilePath)
	}
	return nil // Redis stores don't need explicit persistence
}

// === Config Getters and Setters ===

// GetConfig returns the agent configuration
func (agent *BaseAgent) GetConfig() agents.Config {
	return agent.config
}

// SetConfig updates the agent configuration
func (agent *BaseAgent) SetConfig(config agents.Config) {
	agent.config = config
}

// SaveLastEmbeddingRequest saves the last embedding request JSON for logging/debugging purposes
func (agent *BaseAgent) SaveLastEmbeddingRequest() error {

	bparam, err := agent.EmbeddingParams.MarshalJSON()
	if err != nil {
		agent.log.Error("Error saving last embedding request: %v", err)
		return err
	}
	agent.lastRequestJSON = string(bparam)
	agent.log.Debug("ðŸ“¡ Request Sent:\n%s", agent.lastRequestJSON)

	return nil
}

func (agent *BaseAgent) SaveLastEmbeddingResponse(embeddingResponse *openai.CreateEmbeddingResponse) error {
	//Store last request and response JSON for telemetry or debugging
	agent.lastResponseJSON = embeddingResponse.RawJSON()
	agent.log.Debug("ðŸ“ Response Received:\n%s", agent.lastResponseJSON)
	return nil
}

func (agent *BaseAgent) GetLastRequestRawJSON() string {
	return agent.lastRequestJSON
}
func (agent *BaseAgent) GetLastResponseRawJSON() string {
	return agent.lastResponseJSON
}

func (agent *BaseAgent) GetLastRequestSON() (string, error) {
	return conversion.PrettyPrint(agent.lastRequestJSON)
}

func (agent *BaseAgent) GetLastResponseJSON() (string, error) {
	return conversion.PrettyPrint(agent.lastResponseJSON)
}

// GetContext returns the agent's context
func (agent *BaseAgent) GetContext() context.Context {
	return agent.ctx
}

// SetContext updates the agent's context
func (agent *BaseAgent) SetContext(ctx context.Context) {
	agent.ctx = ctx
}

// === Store Configuration Options ===

// WithInMemoryStore configures the agent to use in-memory vector storage
// This is the default behavior, so this option is only needed if you want to be explicit
func WithInMemoryStore() AgentOption {
	return func(agent *BaseAgent) {
		agent.store = &stores.MemoryVectorStore{
			Records: make(map[string]stores.VectorRecord),
		}
	}
}

// WithJsonStore configures the agent to use JSON file-based vector storage
// It creates an in-memory store and automatically loads data from the specified file if it exists.
// If the file doesn't exist or is empty, it initializes an empty in-memory store.
//
// Parameters:
//   - storePathFile: path to the JSON file for storing vector embeddings
//
// Example:
//
//	ragAgent, err := rag.NewAgent(
//	    ctx,
//	    agents.Config{EngineURL: "http://localhost:12434/engines/llama.cpp/v1"},
//	    models.Config{Name: "ai/mxbai-embed-large:latest"},
//	    rag.WithJsonStore("./store/embeddings.json"),
//	)
//
// Note: You can later persist changes using agent.PersistStore(storePathFile)
func WithJsonStore(storePathFile string) AgentOption {
	return func(agent *BaseAgent) {
		// Store the file path for automatic persistence
		agent.jsonStorePathFile = storePathFile

		// Create a new in-memory store
		memStore := &stores.MemoryVectorStore{
			Records: make(map[string]stores.VectorRecord),
		}

		// Try to load existing data from file
		if err := memStore.Load(storePathFile); err != nil {
			// File doesn't exist or is invalid - use empty store
			agent.log.Debug("Could not load store from %s (will use empty store): %v", storePathFile, err)
		} else {
			agent.log.Debug("Successfully loaded store from %s", storePathFile)
		}

		agent.store = memStore
	}
}

// WithRedisStore configures the agent to use Redis as the vector storage backend
// Parameters:
//   - config: Redis connection configuration (address, password, DB, index name)
//   - dimension: the dimension of embedding vectors (must match your embedding model)
//
// Example:
//
//	ragAgent, err := rag.NewBaseAgent(
//	    ctx,
//	    agents.Config{EngineURL: "http://localhost:12434/engines/llama.cpp/v1"},
//	    openai.EmbeddingNewParams{Model: "ai/mxbai-embed-large"},
//	    rag.WithRedisStore(stores.RedisConfig{
//	        Address:   "localhost:6379",
//	        Password:  "",
//	        DB:        0,
//	        IndexName: "my_rag_index",
//	    }, 1024),
//	)
func WithRedisStore(config stores.RedisConfig, dimension int) AgentOption {
	return func(agent *BaseAgent) {
		redisStore, err := stores.NewRedisVectorStore(agent.ctx, config, dimension)
		if err != nil {
			agent.log.Error("Failed to create Redis vector store: %v", err)
			// Fall back to in-memory store
			agent.store = &stores.MemoryVectorStore{
				Records: make(map[string]stores.VectorRecord),
			}
			return
		}
		agent.store = redisStore
	}
}

// documentExistsInStore checks if a document with the given prompt already exists in the store
// It performs an exact match comparison on the Prompt field of VectorRecords
func documentExistsInStore(store stores.VectorStore, prompt string) (bool, error) {
	existingRecords, err := store.GetAll()
	if err != nil {
		return false, err
	}

	for _, record := range existingRecords {
		if record.Prompt == prompt {
			return true, nil
		}
	}

	return false, nil
}

// WithDocuments initializes the RAG agent with a predefined list of documents
// This option generates embeddings for each document and saves them to the store.
//
// Parameters:
//   - documents: slice of strings to be embedded and stored
//   - mode: optional DocumentLoadMode defining behavior when store already contains data
//     (default: DocumentLoadModeMerge - adds to existing data)
//
// Modes:
//   - DocumentLoadModeOverwrite: clears existing data before loading documents
//   - DocumentLoadModeMerge: adds documents to existing data (default)
//   - DocumentLoadModeSkip: does nothing if store already contains data
//   - DocumentLoadModeSkipDuplicates: checks each document individually and skips only duplicates (based on Prompt content)
//   - DocumentLoadModeError: returns error (logged) if store is not empty
//
// Example:
//
//	ragAgent, err := rag.NewAgent(
//	    ctx,
//	    agents.Config{EngineURL: "http://localhost:12434/engines/llama.cpp/v1"},
//	    models.Config{Name: "ai/mxbai-embed-large:latest"},
//	    rag.WithJsonStore("./store/embeddings.json"),
//	    rag.WithDocuments([]string{
//	        "Squirrels run in the forest",
//	        "Birds fly in the sky",
//	        "Frogs swim in the pond",
//	    }, rag.DocumentLoadModeMerge),
//	)
//
// Example with Redis and SkipDuplicates (prevents duplicate documents on restart):
//
//	ragAgent, err := rag.NewBaseAgent(
//	    ctx,
//	    agents.Config{EngineURL: "http://localhost:12434/engines/llama.cpp/v1"},
//	    openai.EmbeddingNewParams{Model: "ai/mxbai-embed-large"},
//	    rag.WithRedisStore(stores.RedisConfig{
//	        Address:   "localhost:6379",
//	        IndexName: "my_rag_index",
//	    }, 1024),
//	    rag.WithDocuments(txtChunks, rag.DocumentLoadModeSkipDuplicates),
//	)
//
// IMPORTANT: This option must be applied AFTER WithJsonStore or WithRedisStore
// to ensure documents are saved to the correct store.
//
// Note: For JSON stores, you may need to call agent.PersistStore(filePath) after
// agent creation to save the initialized data to disk. Redis stores persist automatically.
func WithDocuments(documents []string, mode ...DocumentLoadMode) AgentOption {
	return func(agent *BaseAgent) {
		// Determine the load mode (default to Merge)
		loadMode := DocumentLoadModeMerge
		if len(mode) > 0 {
			loadMode = mode[0]
		}

		// Check if store already contains data
		existingRecords, err := agent.store.GetAll()
		if err != nil {
			agent.log.Error("Failed to check existing store data: %v", err)
			return
		}

		hasExistingData := len(existingRecords) > 0

		// Handle different load modes
		switch loadMode {
		case DocumentLoadModeError:
			if hasExistingData {
				agent.log.Error("Store already contains data and DocumentLoadModeError is set")
				return
			}

		case DocumentLoadModeSkip:
			if hasExistingData {
				agent.log.Debug("Store already contains data, skipping document loading (DocumentLoadModeSkip)")
				return
			}

		case DocumentLoadModeSkipDuplicates:
			// Check each document individually and skip only duplicates
			if hasExistingData {
				agent.log.Debug("Checking documents individually for duplicates (DocumentLoadModeSkipDuplicates)")
			}

		case DocumentLoadModeOverwrite:
			if hasExistingData {
				// Clear existing data if the store supports it
				if resettable, ok := agent.store.(interface{ ResetMemory() error }); ok {
					if err := resettable.ResetMemory(); err != nil {
						agent.log.Error("Failed to reset store: %v", err)
						return
					}
					agent.log.Debug("Store cleared (DocumentLoadModeOverwrite)")
				} else {
					agent.log.Warn("Store does not support reset, cannot overwrite existing data")
					return
				}
			}

		case DocumentLoadModeMerge:
			// Default behavior - just add to existing data
			if hasExistingData {
				agent.log.Debug("Merging documents with existing data (DocumentLoadModeMerge)")
			}
		}

		// Load documents
		agent.log.Debug("Loading %d documents into store", len(documents))
		skippedCount := 0
		addedCount := 0

		for idx, doc := range documents {
			// Check for duplicates if in SkipDuplicates mode
			if loadMode == DocumentLoadModeSkipDuplicates {
				exists, err := documentExistsInStore(agent.store, doc)
				if err != nil {
					agent.log.Error("Failed to check document existence for document %d: %v", idx, err)
					continue
				}
				if exists {
					agent.log.Debug("Document %d already exists, skipping (duplicate)", idx)
					skippedCount++
					continue
				}
			}

			// Save the document
			if err := agent.GenerateThenSaveEmbeddingVector(doc); err != nil {
				agent.log.Error("Failed to save embedding for document %d: %v", idx, err)
			} else {
				agent.log.Debug("Successfully saved embedding for document %d", idx)
				addedCount++
			}
		}

		// Log summary if in SkipDuplicates mode
		if loadMode == DocumentLoadModeSkipDuplicates {
			agent.log.Debug("Document loading complete: %d added, %d skipped (duplicates)", addedCount, skippedCount)
		}

		// Track the number of documents added for automatic persistence
		agent.documentsAddedCount = addedCount
	}
}

package rag

import (
	"context"
	"errors"

	"github.com/openai/openai-go/v3"
	"github.com/snipwise/nova/nova-sdk/agents"
	"github.com/snipwise/nova/nova-sdk/models"
	"github.com/snipwise/nova/nova-sdk/toolbox/logger"
)

// VectorRecord represents a vector record with prompt and embedding
type VectorRecord struct {
	ID        string
	Prompt    string
	Embedding []float64
	Metadata  map[string]any
	// CosineSimilarity
	Similarity float64
}

// Note: Store configuration options (WithInMemoryStore, WithRedisStore) are defined
// in rag.base.agent.go and can be used directly with NewAgent since they are AgentOption types

// RagAgentOption is a functional option for configuring an Agent during creation
type RagAgentOption func(*Agent)

// BeforeCompletion sets a hook that is called before each embedding generation
func BeforeCompletion(fn func(*Agent)) RagAgentOption {
	return func(a *Agent) {
		a.beforeCompletion = fn
	}
}

// AfterCompletion sets a hook that is called after each embedding generation
func AfterCompletion(fn func(*Agent)) RagAgentOption {
	return func(a *Agent) {
		a.afterCompletion = fn
	}
}

// Agent represents a simplified RAG agent that hides OpenAI SDK details
type Agent struct {
	config        agents.Config
	modelConfig   models.Config
	internalAgent *BaseAgent
	log           logger.Logger

	// Lifecycle hooks
	beforeCompletion func(*Agent)
	afterCompletion  func(*Agent)
}

// NewAgent creates a new simplified RAG agent
func NewAgent(
	ctx context.Context,
	agentConfig agents.Config,
	modelConfig models.Config,
	options ...any,
) (*Agent, error) {
	log := logger.GetLoggerFromEnv()

	// Separate AgentOption (for BaseAgent) from RagAgentOption (for Agent)
	var baseOptions []AgentOption
	var agentOptions []RagAgentOption
	for _, opt := range options {
		switch o := opt.(type) {
		case AgentOption:
			baseOptions = append(baseOptions, o)
		case RagAgentOption:
			agentOptions = append(agentOptions, o)
		}
	}

	// Create internal OpenAI-based agent with converted parameters
	openaiModelConfig := openai.EmbeddingNewParams{
		Model: modelConfig.Name,
	}

	internalAgent, err := NewBaseAgent(ctx, agentConfig, openaiModelConfig, baseOptions...)
	if err != nil {
		return nil, err
	}

	agent := &Agent{
		config:        agentConfig,
		modelConfig:   modelConfig,
		internalAgent: internalAgent,
		log:           log,
	}

	// Apply RagAgentOption configurations
	for _, opt := range agentOptions {
		opt(agent)
	}

	return agent, nil
}

// Kind returns the agent type
func (agent *Agent) Kind() agents.Kind {
	return agents.Rag
}

func (agent *Agent) GetName() string {
	return agent.config.Name
}

func (agent *Agent) GetModelID() string {
	return agent.modelConfig.Name
}

// GenerateEmbedding creates a vector embedding for the given text content
func (agent *Agent) GenerateEmbedding(content string) ([]float64, error) {
	if content == "" {
		return nil, errors.New("content cannot be empty")
	}

	// Call before completion hook if set
	if agent.beforeCompletion != nil {
		agent.beforeCompletion(agent)
	}

	result, err := agent.internalAgent.GenerateEmbeddingVector(content)

	// Call after completion hook if set
	if agent.afterCompletion != nil {
		agent.afterCompletion(agent)
	}

	return result, err
}

// GetEmbeddingDimension returns the dimension of the embedding vectors generated by the agent's model
func (agent *Agent) GetEmbeddingDimension() int {
	return agent.internalAgent.GetEmbeddingDimension()
}

// SaveEmbedding generates and saves an embedding for the given content into the in memory agent's vector store
func (agent *Agent) SaveEmbedding(content string) error {
	if content == "" {
		return errors.New("content cannot be empty")
	}

	return agent.internalAgent.GenerateThenSaveEmbeddingVector(content)
}

// SaveEmbeddingIntoMemoryVectorStore generates and saves an embedding for the given content into the in memory agent's vector store
func (agent *Agent) SaveEmbeddingIntoMemoryVectorStore(content string) error {
	if content == "" {
		return errors.New("content cannot be empty")
	}

	return agent.internalAgent.GenerateThenSaveEmbeddingVector(content)
}

func (agent *Agent) LoadStore(storeFilePath string) error {
	// Check if the store supports persistence
	if persistable, ok := agent.internalAgent.store.(interface {
		Load(string) error
	}); ok {
		return persistable.Load(storeFilePath)
	}
	return errors.New("this store does not support file-based persistence (e.g., Redis stores)")
}

func (agent *Agent) PersistStore(storeFilePath string) error {
	// Check if the store supports persistence
	if persistable, ok := agent.internalAgent.store.(interface {
		Persist(string) error
	}); ok {
		return persistable.Persist(storeFilePath)
	}
	return errors.New("this store does not support file-based persistence (e.g., Redis stores)")
}

func (agent *Agent) StoreFileExists(storeFilePath string) bool {
	// Check if the store supports persistence
	if persistable, ok := agent.internalAgent.store.(interface {
		StoreFileExists(string) bool
	}); ok {
		return persistable.StoreFileExists(storeFilePath)
	}
	return false
}

// SearchSimilar searches for similar records based on content
// limit is the minimum cosine similarity threshold (1.0 = exact match, 0.0 = no similarity)
func (agent *Agent) SearchSimilar(content string, limit float64) ([]VectorRecord, error) {
	if content == "" {
		return nil, errors.New("content cannot be empty")
	}

	results, err := agent.internalAgent.SearchSimilarities(content, limit)
	if err != nil {
		return nil, err
	}

	// Convert internal VectorRecord to public VectorRecord
	publicResults := make([]VectorRecord, len(results))
	for i, result := range results {
		publicResults[i] = VectorRecord{
			ID:        result.Id,
			Prompt:    result.Prompt,
			Embedding: result.Embedding,
			//Metadata:   result,
			Similarity: result.CosineSimilarity,
		}
	}

	return publicResults, nil
}

// SearchTopN searches for top N similar records based on content
// limit is the minimum cosine similarity threshold (1.0 = exact match, 0.0 = no similarity)
// n is the maximum number of results to return
func (agent *Agent) SearchTopN(content string, limit float64, n int) ([]VectorRecord, error) {
	if content == "" {
		return nil, errors.New("content cannot be empty")
	}

	if n <= 0 {
		return nil, errors.New("n must be greater than 0")
	}

	results, err := agent.internalAgent.SearchTopNSimilarities(content, limit, n)
	if err != nil {
		return nil, err
	}

	// Convert internal VectorRecord to public VectorRecord
	publicResults := make([]VectorRecord, len(results))
	for i, result := range results {
		publicResults[i] = VectorRecord{
			ID:        result.Id,
			Prompt:    result.Prompt,
			Embedding: result.Embedding,
			//Metadata:   result.Metadata,
			Similarity: result.CosineSimilarity,
		}
	}

	return publicResults, nil
}

// === Config Getters and Setters ===

// GetConfig returns the agent configuration
func (agent *Agent) GetConfig() agents.Config {
	return agent.config
}

// SetConfig updates the agent configuration
func (agent *Agent) SetConfig(config agents.Config) {
	agent.config = config
	agent.internalAgent.SetConfig(config)
}

// GetModelConfig returns the model configuration
func (agent *Agent) GetModelConfig() models.Config {
	return agent.modelConfig
}

// SetModelConfig updates the model configuration
// Note: For RAG agents, changing the model config requires recreating the agent
// as the embedding parameters are set during initialization
func (agent *Agent) SetModelConfig(config models.Config) {
	agent.modelConfig = config
}

func (agent *Agent) GetLastRequestRawJSON() string {
	return agent.GetLastRequestRawJSON()
}
func (agent *Agent) GetLastResponseRawJSON() string {
	return agent.GetLastResponseRawJSON()
}

func (agent *Agent) GetLastRequestJSON() (string, error) {
	return agent.GetLastRequestJSON()
}

func (agent *Agent) GetLastResponseJSON() (string, error) {
	return agent.GetLastResponseJSON()
}

// GetContext returns the agent's context
func (agent *Agent) GetContext() context.Context {
	return agent.internalAgent.GetContext()
}

// SetContext updates the agent's context
func (agent *Agent) SetContext(ctx context.Context) {
	agent.internalAgent.SetContext(ctx)
}
